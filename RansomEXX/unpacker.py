#!/usr/bin/env python3
#_coding: UTF-8
# pylint: disable=C0301
"""
This scripts helps to decrypt the stage2 from a ransomEXX packed file
"""
import sys
import array
import struct
from typing import Optional
import click
import numpy as np
import pefile

__author__ = "Pezier Pierre-Henri"
__copyright__ = "Copyright (C) 2022 Tehtris"
__license__ = "Public Domain"
__version__ = "1.0"

CHUNK_SIZE = 77
PADDING_SIZE = 51


def get_section_data(mype: pefile.PE) -> Optional[bytes]:
    """Retreive the section associated with stage2"""
    for res_type in mype.DIRECTORY_ENTRY_RESOURCE.entries:
        for resource_id in res_type.directory.entries:
            try:
                if resource_id.name.string == b"A":
                    offset = resource_id.directory.entries[0].data.struct.OffsetToData
                    length = resource_id.directory.entries[0].data.struct.Size
                    return mype.get_data(offset, length)
            except AttributeError:
                continue
    return None


def pe_hunt(data: bytes) -> Optional[bytes]:
    """Extract the PE from stage2 shellcode"""
    for i in range(0, len(data)):
        try:
            mype = pefile.PE(data=data[i:], fast_load=True)
            pe_size = max(section.SizeOfRawData + section.PointerToRawData for section in mype.sections)
            return data[i:i+pe_size]
        except pefile.PEFormatError:
            continue
    return None


def check_key(data: bytes, key: int = 0x8b3c1) -> bool:
    """Check if key is valid"""
    trailing_dword = np.uint32(struct.unpack("<I", data[-4:])[0])
    trailing_dword = trailing_dword + len(data) - 4
    trailing_dword = trailing_dword ^ ((len(data) - 4) + key)
    return trailing_dword == 0


def bf_key(data) -> int:
    """Bruteforce the deobfuscation key"""
    for i in range(0, 0xFFFFFFFF):
        if check_key(data, i):
            return i
    raise TypeError("Cannot find encryption key")


def decrypt_stage2(data: bytes, key: int = 0) -> bytes:
    """Pass the stage2 deobfuscation algorithm"""
    if not key:
        key = bf_key(data)
    myarray = array.array("I", data)
    for offset, val in enumerate(myarray):
        myarray[offset] = np.uint32(val + offset * 4)  # needs np to force overflow
        myarray[offset] = np.uint32(myarray[offset] ^ (offset * 4 + key))
    return myarray.tobytes()


@click.command()
@click.option('--inputfile', type=click.Path(exists=True), nargs=1, required=True, help="Input ransomEXX packed file")
@click.option('--outputfile', type=click.Path(exists=False), nargs=1, required=True, help="Output extracted stage2 file")
def unpack(inputfile: str, outputfile: str) -> None:
    """Unpack a stage2 from ransomEXX"""
    mype = pefile.PE(inputfile)
    try:
        data = get_section_data(mype)
    except AttributeError:
        click.echo("Not a valid ransomEXX executable", err=True)
        sys.exit(1)
    if data:
        stage2_entry_point = struct.unpack("<I", data[:4])[0]
        if stage2_entry_point > len(data):
            print()
            return
        encrypted_data = b''
        for i in range(4, len(data), CHUNK_SIZE + PADDING_SIZE):
            encrypted_data += data[i:i+CHUNK_SIZE]
        decrypted_data = decrypt_stage2(encrypted_data)
        stage2_pe = pe_hunt(decrypted_data)
        if stage2_pe:
            open(outputfile, 'wb').write(stage2_pe)
        else:
            click.echo("Cannot find stage2 in pe", err=True)
            sys.exit(1)
    else:
        click.echo("Does not seems to be a valid ransomEXX stage1", err=True)
        sys.exit(1)


if __name__ == '__main__':
    unpack()  # pylint: disable=E1120
