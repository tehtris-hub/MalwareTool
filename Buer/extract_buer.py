"""
Minimalist emulator
"""
#pylint: disable=C0301
from typing import Dict, Optional, Set, Callable
import struct
import pathlib
import lzma
import time
import magic
import unicorn
from Cryptodome.Cipher import ARC4
import pefile
import idaapi  #pylint: disable=E0401
import idc  #pylint: disable=E0401
import ida_pro  #pylint: disable=E0401
import ida_dbg  #pylint: disable=E0401
import ida_kernwin  #pylint: disable=E0401


class Conf:
    """Buer specific extraction conf"""
    autorun: bool = False
    entrypoint: int = 0x6A20F0
    breakpoint_list: Set[int] = {0x6D9514}
    hooks: Dict[str, Callable[['Kernel'], None]]

    def __init__(self, kernel: 'Kernel'):
        """Constructor, you can freely initialyze pointers..."""
        self.hooks = {
            #  Useless calls
            "GetLastError": lambda *args: None, "GetCommandLineA": lambda *args: None, "GetVersion": lambda *args: None,
            "GetEnvironmentStrings": lambda *args: None, "GetProcessHeap": lambda *args: None,
            "GetTickCount": lambda *args: None, "GetCurrentProcess": lambda *args: None,
            #  Heap related functions
            "HeapAlloc": Kernel.heapalloc,
            "HeapFree": Kernel.heapfree,
            "HeapReAlloc": Kernel.heaprealloc,
        }
        self.outbuf = kernel.alloc(64)
        kernel.mu.reg_write(unicorn.x86_const.UC_X86_REG_ECX, self.outbuf)

    def breakpoint_callback(self, kernel: 'Kernel'):
        """Called when a breapoint is reached"""
        try:
            rc4key = bytes(kernel.mu.mem_read(kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_EAX), 10))
            print("rc4key:", rc4key)
            addr, length = struct.unpack("<II", bytes(kernel.mu.mem_read(self.outbuf, 8)))
            print("Found payload at:", hex(addr), "len:", hex(length))
            payload_cleartext = ARC4.new(rc4key).decrypt(bytes(kernel.mu.mem_read(addr, length)))
            payload_decompressed = lzma.decompress(payload_cleartext)
            print("Found Stage2 Payload:", magic.from_buffer(payload_decompressed))
            try:  # try automated extraction
                open(idc.ARGV[1], "wb").write(payload_decompressed)
            except IndexError:  # Ask user for a dump
                filename = ida_kernwin.ask_file(1, ".exe", "Save Stage2")
                if filename:
                    open(filename, "wb").write(payload_decompressed)
            if self.autorun:
                ida_pro.qexit(0)
        except lzma.LZMAError:
            pass  # must be user defined bp


class Kernel:
    """Minimalist kernel emulator"""
    peexe: pefile.PE
    do_refresh = True
    heap_offset: int
    stack_offset: int
    heap_size = 1024 * 1024 * 10
    stack_size = 1024 * 1024
    pages: Dict[int, int] = {heap_size: 0}
    mu: unicorn.unicorn.Uc = unicorn.Uc(unicorn.UC_ARCH_X86, unicorn.UC_MODE_32)
    Ã¬nst: int
    conf: Conf
    import_list: set = set()

    def __init__(self, filepath: pathlib.Path):
        self.peexe = pefile.PE(filepath)
        try:
            self.peexe = pefile.PE(filepath)
        except pefile.PEFormatError:
            raise TypeError(f'File "{filepath}" is not a pe format')
        if self.peexe.FILE_HEADER.Machine != 0x14c:
            raise NotImplementedError("64 bit not supported yet")

        raw_data = filepath.read_bytes()
        virt_data = b''

        for section in self.peexe.sections:
            sectiondata = raw_data[section.PointerToRawData:section.PointerToRawData + section.SizeOfRawData]
            virt_data += b'\x00' * (section.VirtualAddress - len(virt_data))
            virt_data = virt_data[:section.VirtualAddress] + sectiondata + virt_data[section.VirtualAddress + len(sectiondata):]

        self.heap_offset = len(virt_data)
        virt_data += b'\x00' * self.heap_size
        self.stack_offset = len(virt_data)
        virt_data += b'\x00' * self.stack_size
        memory = self._align(virt_data)

        print(f"Memory mapped: {hex(self.peexe.OPTIONAL_HEADER.ImageBase)} - {hex(self.peexe.OPTIONAL_HEADER.ImageBase + len(memory))}")

        self.mu.mem_map(self.peexe.OPTIONAL_HEADER.ImageBase, len(memory))
        self.mu.mem_write(self.peexe.OPTIONAL_HEADER.ImageBase, memory)
        self.mu.reg_write(unicorn.x86_const.UC_X86_REG_ESP, self.peexe.OPTIONAL_HEADER.ImageBase + self.stack_offset)
        self.mu.hook_add(unicorn.UC_HOOK_MEM_WRITE, self._hook_mem_access, self)
        self.mu.hook_add(unicorn.UC_HOOK_MEM_READ, self._hook_mem_access, self)
        self.mu.hook_add(unicorn.UC_HOOK_CODE, self._hook_code, self)

        if hasattr(self.peexe, "DIRECTORY_ENTRY_IMPORT"):
            for entry in self.peexe.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode('utf-8').lower()
                for func in entry.imports:
                    self.import_list.add(str(func.name, 'UTF-8'))
        self.conf = Conf(self)
        if not self.mu.reg_read(unicorn.x86_const.UC_X86_REG_EIP):
            if self.conf.entrypoint:
                self.inst = self.conf.entrypoint + self.peexe.OPTIONAL_HEADER.ImageBase - idaapi.get_imagebase()
            else:
                self. inst = idc.get_curline()
                if self.inst == idaapi.BADADDR:
                    self.inst = ida_kernwin.ask_long(0, "entry point") + self.peexe.OPTIONAL_HEADER.ImageBase - idaapi.get_imagebase()
        self.mu.reg_write(unicorn.x86_const.UC_X86_REG_EIP, self.inst)
        self.conf.entrypoint = self.inst
        self.refresh_display()

    def _hook_mem_read(self, myuc: unicorn.unicorn.Uc, address: int, size: int, value: bytes):
        pass

    def _hook_mem_write(self, myuc: unicorn.unicorn.Uc, address: int, size: int, value: bytes):
        pass

    @staticmethod
    def _hook_mem_access(myuc: unicorn.unicorn.Uc, access: int, address: int, size: int, value: bytes, self) -> None:
        if access == unicorn.UC_MEM_WRITE:
            self._hook_mem_write(myuc, address, size, value)  #pylint: disable=W0212
        elif access == unicorn.UC_MEM_READ:
            self._hook_mem_read(myuc, address, size, value)  #pylint: disable=W0212

    @staticmethod
    def _hook_code(myuc: unicorn.unicorn.Uc, address: int, size: int, self) -> None:
        self.hook_code(myuc, address, size)

    def hook_code(self, uc: unicorn.unicorn.Uc, address: int, size: int) -> None:
        """Called every time an instruction has been emulated"""
        stopaddr = self.inst + idc.get_item_size(self._fix_offset(self.inst))
        if address not in [self.inst, stopaddr]:
            self.mu.emu_stop()

    def _fix_offset(self, myea: int) -> int:
        return myea - self.peexe.OPTIONAL_HEADER.ImageBase + idaapi.get_imagebase()

    @staticmethod
    def _align(buf: bytes, alignment=1024*1024) -> bytes:
        """Add null bytes padding to extend a buffer to modulo alignment"""
        if len(buf) % alignment == 0:
            return buf
        return buf + (alignment - (len(buf) % alignment)) * b'\x00'

    def realloc(self, addr: int, length: int) -> int:
        """Free the page pointed by addr, and realloc it"""
        orglength = self.pages[addr - self.heap_offset - self.peexe.OPTIONAL_HEADER.ImageBase]
        data = self.mu.mem_read(addr, orglength)
        self.free(addr)
        newaddr = self.alloc(length)
        self.mu.mem_write(newaddr, bytes(data))
        return newaddr

    def alloc(self, length: int = 0) -> Optional[int]:
        """This must be called by a hook of HeapAlloc"""
        if not length:
            length = struct.unpack('<I', self.get_arg(2))[0]
        if 0 not in self.pages:
            self.pages[0] = 0

        for i in range(len(self.pages) - 1):
            curraddr = self.pages[sorted(list(self.pages))[i]] + sorted(list(self.pages))[i]
            if sorted(list(self.pages))[i + 1] - curraddr >= length:
                self.pages[curraddr] = length
                return curraddr + self.peexe.OPTIONAL_HEADER.ImageBase + self.heap_offset
        raise MemoryError('VM Stack full')

    def free(self, addr):
        """Free a memory page"""
        del self.pages[addr - self.heap_offset - self.peexe.OPTIONAL_HEADER.ImageBase]

    def get_arg(self, index):
        """Retreive element pushed on the stack"""
        esp = self.mu.reg_read(unicorn.x86_const.UC_X86_REG_ESP)
        return self.mu.mem_read(esp + 4 * index, 4)

    def single_step(self):
        """Execute a single step"""
        for i in range(ida_dbg.get_bpt_qty()):
            self.set_break_point(idc.get_bpt_ea(i))
        self.inst = self.mu.reg_read(unicorn.x86_const.UC_X86_REG_EIP)
        idaapi.set_item_color(self._fix_offset(self.inst), idc.DEFCOLOR)
        if idc.get_operand_type(self.inst, 0) in [idc.o_far, idc.o_near]:
            call = idc.generate_disasm_line(self.inst, 0).split()[-1]
            if call in self.import_list or call in self.conf.hooks:
                if call in self.conf.hooks:
                    self.conf.hooks[call](self)
                    self.inst += idc.get_item_size(self._fix_offset(self.inst))
                    self.mu.reg_write(unicorn.x86_const.UC_X86_REG_EIP, self.inst)
                    self.refresh_display()
                    return
                raise StopIteration(f'Unknown Call: "{call}" Cannot continue\n')

        self.mu.emu_start(self.inst, self.inst + idc.get_item_size(self._fix_offset(self.inst)))
        self.inst = self.mu.reg_read(unicorn.x86_const.UC_X86_REG_EIP)
        self.refresh_display()

    def refresh_display(self):
        """Highlight EIP"""
        if self.do_refresh:
            idaapi.set_item_color(self._fix_offset(self.mu.reg_read(unicorn.x86_const.UC_X86_REG_EIP)), 0x00FF00)
            ida_kernwin.jumpto(self._fix_offset(self.mu.reg_read(unicorn.x86_const.UC_X86_REG_EIP)))

    def run(self):
        """run the debugger"""
        self.do_refresh = False
        myt1 = time.time()
        try:
            while True:
                self.single_step()
                if not all(self._fix_offset(x) != self.inst for x in self.conf.breakpoint_list):
                    break
            print("Breakpoint reached")
            self.do_refresh = True
            self.refresh_display()
            if hasattr(self.conf, "breakpoint_callback"):
                self.conf.breakpoint_callback(self)
        except StopIteration as error:
            print(error)
        finally:
            self.do_refresh = True
        print(f"I runned for {time.time() - myt1} seconds")

    def set_break_point(self, addr=0) -> None:
        """Set a breakpoint in the Conf class"""
        if not addr:
            addr = ida_kernwin.ask_long(0, "bp address")
        self.conf.breakpoint_list.add(addr)

    @staticmethod
    def heapalloc(kernel: 'Kernel'):
        """Heapalloc hook"""
        length = struct.unpack('<I', kernel.get_arg(2))[0]
        addr = kernel.alloc(length)
        kernel.mu.reg_write(unicorn.x86_const.UC_X86_REG_EAX, addr)
        print(f"Hooked HeapAlloc({hex(length)}) -> {hex(addr)}")
        esp = kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_ESP)
        kernel.mu.reg_write(unicorn.x86_const.UC_X86_REG_ESP, esp + 4 * 3)

    @staticmethod
    def heapfree(kernel: 'Kernel'):
        """Heapfree hook"""
        addr = struct.unpack('<I', kernel.get_arg(2))[0]
        print(f"HeapFree({hex(addr)})")
        try:
            kernel.free(addr)
            esp = kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_ESP)
            kernel.mu.reg_write(unicorn.x86_const.UC_X86_REG_ESP, esp + 4 * 3)
        except (AttributeError, KeyError) as error:
            raise MemoryError(f"Cannot release: {addr} ({error})")

    @staticmethod
    def heaprealloc(kernel: 'Kernel'):
        """Heaprealloc hook"""
        mem = struct.unpack('<I', kernel.get_arg(2))[0]
        length = struct.unpack('<I', kernel.get_arg(3))[0]
        addr = kernel.realloc(mem, length)
        print(f"HeapRealloc(0, 0, {hex(mem)}, {hex(length)}) -> {hex(addr)}")
        esp = kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_ESP)
        kernel.mu.reg_write(unicorn.x86_const.UC_X86_REG_ESP, esp + 4 * 4)
        kernel.mu.reg_write(unicorn.x86_const.UC_X86_REG_EAX, addr)


class say_something_handler_t(idaapi.action_handler_t):
    """IDA window handler"""
    def __init__(self, thing):
        idaapi.action_handler_t.__init__(self)
        self.thing = thing

    @staticmethod
    def activate(_):
        """Activate window callback"""

    @staticmethod
    def update(_):
        """Update window callback"""
        return idaapi.AST_ENABLE_ALWAYS


class mycv_t(idaapi.simplecustviewer_t):
    """IDA Window class"""
    ref_addr: int = 0
    kernel: Kernel

    def Create(self, kernel: Kernel) -> bool:
        """Constructor"""
        self.kernel = kernel
        if not idaapi.simplecustviewer_t.Create(self, "Tehtris code emulator"):
            return False
        self.show_cpu()
        return True

    def show_cpu(self):
        """Display the CPU and mem dump in window"""
        text = f"""eax    {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_EAX):08x}    xmm0    {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_XMM0):032x}    ymm0       {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_YMM0):064x}
ebx    {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_EBX):08x}    xmm1    {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_XMM1):032x}    ymm1       {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_YMM1):064x}
ecx    {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_ECX):08x}    xmm2    {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_XMM2):032x}    ymm2       {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_YMM2):064x}
edx    {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_EDX):08x}    xmm3    {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_XMM3):032x}    ymm3       {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_YMM3):064x}
ebp    {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_EBP):08x}    xmm4    {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_XMM4):032x}    ymm4       {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_YMM4):064x}
esp    {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_ESP):08x}    xmm5    {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_XMM5):032x}    ymm5       {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_YMM5):064x}
esi    {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_ESI):08x}    xmm6    {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_XMM6):032x}    ymm6       {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_YMM6):064x}
edi    {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_EDI):08x}    xmm7    {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_XMM7):032x}    ymm7       {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_YMM7):064x}
eip    {self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_EIP):08x}

"""
        esp = self.kernel.mu.reg_read(unicorn.x86_const.UC_X86_REG_ESP)
        for i in range(10):
            addr = esp + 4 * i
            val = struct.unpack("<I", bytes(self.kernel.mu.mem_read(addr, 4)))[0]
            text += f"{addr:08x}    {val:08x}\n"
        text += "\n"
        try:
            bindata = bytes(self.kernel.mu.mem_read(self.ref_addr, 6 * 32))
            for i in range(0, 5):
                text += f"{self.ref_addr + 32 * i:08x}  "
                text += ''.join(f'{x:02x} ' for x in bindata[i*32:(i+1)*32]) + "\n"
        except unicorn.unicorn.UcError:
            for i in range(0, 5):
                text += f"{self.ref_addr + 32 * i:08x}  "
                text += '?? ' * 32 + "\n"
        text += """
S: Single step execution, R: Run, ESC: quit
"""
        self.ClearLines()
        for i in text.split('\n'):
            self.AddLine(i)

    def OnDblClick(self, _):
        """
        User dbl-clicked in the view
        @param shift: Shift flag
        @return: Boolean. True if you handled the event
        """
        try:
            if self.GetLineNo() == 21:
                self.ref_addr = int(ida_kernwin.ask_long(0, "Enter Address"), 16)
            else:
                self.ref_addr = int(self.GetCurrentWord(), 16)
            self.show_cpu()
        except ValueError:
            print("Bad Value")
        return True

    def OnCursorPosChanged(self):
        """
        Cursor position changed.
        @return: Nothing
        """

    def OnClose(self):
        """
        The view is closing. Use this event to cleanup.
        @return: Nothing
        """
        print("OnClose " + self.title)

    def OnKeydown(self, vkey, _):
        """
        User pressed a key
        @param vkey: Virtual key code
        @return: Boolean. True if you handled the event
        """
        # ESCAPE?
        if vkey == 27:
            self.Close()
        elif vkey == ord('R'):  # Single Step execution
            self.kernel.run()
            self.show_cpu()
            self.Refresh()
            self.Show()
        elif vkey == ord('S'):  # Single Step execution
            idaapi.get_current_viewer()
            self.kernel.single_step()
            self.show_cpu()
            self.Refresh()
            self.Show()
        else:
            return False
        return True


def show_win(kernel: Kernel) -> Optional[idaapi.simplecustviewer_t]:
    """Display the window in ida pro"""
    win = mycv_t()
    if not win.Create(kernel):
        print("Failed to create!")
        return None
    win.Show()
    return win


KERNEL = Kernel(pathlib.Path(idaapi.get_input_file_path()))
if KERNEL.conf.autorun:
    KERNEL.run()
else:
    MYCV = show_win(KERNEL)
    if not MYCV:
        del MYCV
