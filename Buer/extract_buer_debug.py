# -*- CODING: UTF-8 -*-
"""
IDA script to extract buer stage2
"""
#pylint: disable=C0301
#pylint: disable=E0401
import re
import lzma
import pathlib
from typing import Optional, Tuple
import magic
from Cryptodome.Cipher import ARC4
import idaapi
import idautils
import idc
import ida_dbg

__author__ = "Pezier Pierre-Henri"
__copyright__ = "Copyright (C) 2031 Tehtris"
__license__ = "Public Domain"
__version__ = "1.0"

def get_rc4_key() -> Tuple[int, bytes]:
    """Extract RC4 key. Return tuple: keyoffset VA, keyval"""
    try:
        segstart, seglen = [(idc.get_segm_start(x), idc.get_segm_end(x) - idc.get_segm_start(x)) for x in idautils.Segments() if idc.get_segm_name(x) == ".rdata"][0]
        keyoffset = re.search(rb'[A-Z]{10}capacity overflow', idc.get_bytes(segstart, seglen)).start() + segstart
        return keyoffset, idc.get_bytes(keyoffset, 10)
    except (KeyError, AttributeError):
        return 0, b''


def go_to_decrypt(offset: int) -> bool:
    """Run the debugger until we reach an offset where the key has been decrypted"""
    try:
        reference = [x.frm for x in idautils.XrefsTo(offset)][0]
    except AttributeError:
        return False
    print(f'Found reference: {hex(reference)}')
    if not ida_dbg.dbg_is_loaded():
        print("No debugger selected. Please select a debugger and restart script")
        return False
    ida_dbg.exit_process()
    print("Have a cofee, it will take some time")
    ida_dbg.run_to(reference)
    ida_dbg.wait_for_next_event(ida_dbg.WFNE_SUSP, -1)
    return True


def find_segment() -> bytes:
    """Go throw all the segments until we find encrypted data"""
    for segment in idautils.Segments():
        seglen = idc.get_segm_end(segment) - idc.get_segm_start(segment)
        if idc.get_segm_name(segment).startswith("debug") and seglen > 1024 * 100:
            header = idc.get_bytes(idc.get_segm_start(segment), 32)
            if header[8:16] == b"\x00" * 8 and header[28:] == b"\x00\x00\x00\x04":
                data = idc.get_bytes(idc.get_segm_start(segment) + 32, seglen - 32)
                return data
    return b""

def decrypt(key: bytes, data: bytes) -> bytes:
    """Decrypt and decompress the data. A PE32 is expected"""
    data = ARC4.new(key).decrypt(data)
    if magic.from_buffer(data).startswith('LZMA'):
        print("Found compressed data")
        data = lzma.decompress(data)
        print(f'Found: {magic.from_buffer(data)}')
        return data
    return b""


def extractbuer() -> None:
    """Extract the stage 2 to the disk"""
    offset, key = get_rc4_key()
    if offset:
        print(f'found key: RC4="{str(key, "utf-8")}" at offset: {hex(offset)}')
        if not go_to_decrypt(offset):
            print("Failed to find reference to key")
        else:
            encdata = find_segment()
            ida_dbg.exit_process()
            if not encdata:
                print("Failed to find data section")
            else:
                cleartext = decrypt(key, encdata)
                if not cleartext:
                    print("Failed to extract data")
                else:
                    source = pathlib.Path(idaapi.get_input_file_path())
                    dest = source.parent / (source.with_suffix("").name + "_stage_2.exe")
                    dest.write_bytes(cleartext)
                    print(f'saved to: "{dest}"')
    else:
        print("Cannot find rc4 key")


extractbuer()
